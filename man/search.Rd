% Generated by roxygen2 (4.0.2): do not edit by hand
\name{Search}
\alias{Search}
\title{Full text search of Elasticsearch - URI requests}
\usage{
Search(index = NULL, type = NULL, q = NULL, df = NULL,
  analyzer = NULL, default_operator = NULL, explain = NULL,
  source = NULL, fields = NULL, sort = NULL, track_scores = NULL,
  timeout = NULL, terminate_after = NULL, from = NULL, size = NULL,
  search_type = NULL, lowercase_expanded_terms = NULL,
  analyze_wildcard = NULL, version = FALSE, body = list(), raw = FALSE,
  ...)
}
\arguments{
\item{index}{Index name}

\item{type}{Document type}

\item{q}{The query string (maps to the query_string query, see Query String Query for more
details).}

\item{df}{The default field to use when no field prefix is defined within the query.}

\item{analyzer}{The analyzer name to be used when analyzing the query string.}

\item{default_operator}{The default operator to be used, can be AND or OR. Default: OR.}

\item{explain}{(logical) For each hit, contain an explanation of how scoring of the hits
was computed.}

\item{source}{Set to FALSE to disable retrieval of the _source field. You can also retrieve
part of the document by using _source_include & _source_exclude (see the request body
documentation for more details)}

\item{fields}{The selective stored fields of the document to return for each hit. Not
specifying any value will cause no fields to return.}

\item{sort}{Sorting to perform. Can either be in the form of fieldName, or
fieldName:asc/fieldName:desc. The fieldName can either be an actual field within the document,
or the special _score name to indicate sorting based on scores. There can be several sort
parameters (order is important).}

\item{track_scores}{When sorting, set to TRUE in order to still track scores and return them
as part of each hit.}

\item{timeout}{A search timeout, bounding the search request to be executed within the
specified time value and bail with the hits accumulated up to that point when expired. Default:
no timeout.}

\item{terminate_after}{The maximum number of documents to collect for each shard, upon
reaching which the query execution will terminate early. If set, the response will have a
boolean field terminated_early to indicate whether the query execution has actually
terminated_early. Defaults to no terminate_after.}

\item{from}{The starting from index of the hits to return. Default: 0.}

\item{size}{The number of hits to return. Default: 10.}

\item{search_type}{The type of the search operation to perform. Can be dfs_query_then_fetch,
dfs_query_and_fetch, query_then_fetch, query_and_fetch, count, scan. Default: query_then_fetch.
See Search Type for more details on the different types of search that can be performed.}

\item{lowercase_expanded_terms}{Should terms be automatically lowercased or not. Default: TRUE.}

\item{analyze_wildcard}{Should wildcard and prefix queries be analyzed or not. Default: FALSE.}

\item{version}{(logical) Print the document version with each document.}

\item{body}{Query, either a list or json.}

\item{raw}{If TRUE (default), data is parsed to list. If FALSE, then raw JSON.}

\item{...}{Curl args passed on to \code{\link[httr]{GET}}}
}
\description{
Full text search of Elasticsearch - URI requests
}
\details{
This function name has the "S" capitalized to avoid conflict with the function
\code{base::search}. I hate mixing cases, as I think it confuses users, but in this case
it seems neccessary.
}
\examples{
\donttest{
# URI string queries
search(index="shakespeare")
search(index="shakespeare", type="act")
search(index="shakespeare", type="scene")
search(index="shakespeare", type="line")

## Return certain fields
search(index="shakespeare", fields=c('play_name','speaker'))

## sorting
search(index="shakespeare", type="act", sort="text_entry")
search(index="shakespeare", type="act", sort="speaker:desc", fields='speaker')
search(index="shakespeare", type="act",
 sort=c("speaker:desc","play_name:asc"), fields=c('speaker','play_name'))

## paging
search(index="shakespeare", size=1, fields='text_entry')$hits$hits
search(index="shakespeare", size=1, from=1, fields='text_entry')$hits$hits

## queries
search(index="shakespeare", type="act", q="what")
res <- search(index="shakespeare", type="act", q="speech_number>='2'")
res$hits$total

## more complex queries
search(index="shakespeare", q="what")
res <- search(index="shakespeare", q="speech_number>='2013-10-01'")
search(index="shakespeare", q="createdTime>='2013-10-01'")
search(index="shakespeare", size=1)
search(index="shakespeare", size=1, explain=TRUE)

## terminate query after x documents found
## setting to 1 gives back one document for each shard
search(index="shakespeare", terminate_after=1)
## or set to other number
search(index="shakespeare", terminate_after=2)

## Get version number for each document
search(index="shakespeare", version=TRUE, size=2)

## Get raw data
search(index="shakespeare", type="scene", raw=TRUE)

## Curl debugging
library('httr')
out <- search(index="shakespeare", type="line", config=verbose())



# Query DSL searches - queries sent in the body of the request
# pass in as an R list
aggs <- list(aggs = list(stats = list(terms = list(field = "text_entry"))))
search(index="shakespeare", body=aggs)

# or pass in as json query with newlines, easy to read
aggs <- '{
    "aggs": {
        "stats" : {
            "terms" : {
                "field" : "text_entry"
            }
        }
    }
}'
search(index="shakespeare", body=aggs)

# or pass in collapsed json string
aggs <- '{"aggs":{"stats":{"terms":{"field":"text_entry"}}}}'
search(index="shakespeare", body=aggs)

# match query
match <- '{"query": {"match" : {"text_entry" : "Two Gentlemen"}}}'
search(index="shakespeare", body=match)

# multi-match (multiple fields that is) query
mmatch <- '{"query": {"multi_match" : {"query" : "henry", "fields": ["text_entry","play_name"]}}}'
search(index="shakespeare", body=mmatch)

# bool query
mmatch <- '{
 "query": {
   "bool" : {
     "must_not" : {
       "range" : {
         "speech_number" : {
           "from" : 1, "to": 5
}}}}}}'
search(index="shakespeare", body=mmatch)

# Boosting query
boost <- '{
 "query" : {
  "boosting" : {
      "positive" : {
          "term" : {
              "play_name" : "henry"
          }
      },
      "negative" : {
          "term" : {
              "text_entry" : "thou"
          }
      },
      "negative_boost" : 0.2
    }
 }
}'
search(index="shakespeare", body=mmatch)
}
}
\references{
\url{http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search.html}
}

